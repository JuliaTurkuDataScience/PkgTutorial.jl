var documenterSearchIndex = {"docs":
[{"location":"08_host_docs/#Host-documentation-online","page":"Docs Deployment","title":"Host documentation online","text":"","category":"section"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"Deploying the docs online should go quite smoothly if you managed to build them locally. In case you didn't, deployment on a GitHub Actions host server could actually solve the issues and conflicts you had locally, because it helps run the code in an isolated environment where conflicts between package versions and dependencies are less likely to happen, and if they do happen, that ensures you that is a global problem that inevitably needs to be solved and is not due to your own machine.","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"First off, add this workflow to your .github/workflows directory, maybe as Documenter.yml:","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"name: Documenter\non:\n  - push\n  - pull_request\njobs:\n  docs:\n    name: Documentation\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out\n        uses: actions/checkout@v2\n\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.7'\n\n      - name: Build package\n        run: |\n          julia --project=docs -e '\n            import Pkg; Pkg.add(\"Documenter\")\n            using Pkg\n            Pkg.develop(PackageSpec(path=pwd()))\n            Pkg.instantiate()'\n      - name: Run doctests\n        run: |\n          julia --project=docs -e '\n            import Pkg; Pkg.add(\"Documenter\")\n            using Documenter: doctest\n            using ProjectName\n            doctest(ProjectName)'\n      - name: Deploy documentation\n        run: julia --project=docs docs/make.jl\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          DOCUMENTER_KEY: ${{ secrets.DOCUMENTER_KEY }}","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"Next, commit the changes to main. After the workflow has run, a new branch \"gh-pages\" should be automatically created. In case it isn't, you have to go to the repo settings and manually set gh-pages as the default branch for deployment. From now on, every time you push a new tag to main, the latest version of the docs will be rendered at \"https://OrganisationName.github.io/ProjectName.jl/stable/\". Practically, here's what you need to do to trigger deployment:","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"# commit changes locally\ngit commit -m \"Add new features\"\n# create a new tag locally\ngit tag -a v0.1.0 -m \"Release version 0.1.0\"\n# push changes to origin/main\ngit push origin main\n# push tags to origin\ngit push --tag","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"Then the Documenter.jl workflow should be triggered and will be followed by another workflow named \"pages build and deployment\", which will present you the link to your new website. It is nice to wrap it up into a badge and showcase it in the README.","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"Keep in mind that reusing tags, pushing commits but no new tags or tags but no new commits won't trigger deployment (yes, I tried all of that). Sometimes you might need to delete older tags both locally and on GitHub, because they tend to cluster very quickly and you can't come up with any new names for the tags. Sometimes you also need to clear the cookies from your browser before you're able to see the latest version of the docs.","category":"page"},{"location":"08_host_docs/","page":"Docs Deployment","title":"Docs Deployment","text":"Learn more about hosting documentation at JuliaNotes.jl and Documenter.jl.","category":"page"},{"location":"01_basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"To start off, write down some content in a julia script, say example.jl; for instance, it may entail a working example of the functionality you'd like to offer through your new package. Once you realise that some of the code you wrote could be wrapped up into one or more functions, define those functions and move them into a separate file, say main.jl.","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"You can now import the utilities from main.jl to example.jl with:","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"include(\"main.jl\")","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"But if main.jl lives in a subdirectory, you'll have to let Julia know about it. One option is to specify the relative path of the file in the include command. A better option is to push a custom path in the loading path of Julia:","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"push!(LOAD_PATH, \"subdirectory\")","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"Also, if you want to use external utilities, call them in main.jl and they will also be exported in example.jl:","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"# lazy load module\nimport FdeSolver\n# load module and export all functions\nusing MicrobiomeTools","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"All of the above works as a good temporary solution, as long as you don't need external utilites or multiple source scripts. In such case, you might want to define a module within a new file SomeModule.jl, wich will function as the core of your new package:","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"# define module to load all ingredients you need for your package to work\nmodule SomeModule\n\n# 1. load externals\nimport FdeSolver\nusing MicrobiomeTools\n\n# 2. include internals\ninclude(\"main1.jl\")\ninclude(\"main2.jl\")\n\n# 3. export internals\nexport my_function1\nexport my_function2\n\nend","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"Now you can run something like using SomeModule in your example.jl script and hopefully you'll have access to your functions without having to deal with errors. If you do run into errors, try to troubleshoot with push! or reboot Julia.","category":"page"},{"location":"01_basics/","page":"Basics","title":"Basics","text":"Learn more about modules at JuliaLang and JuliaNotes.jl.","category":"page"},{"location":"10_sources/#Find-more-answers","page":"Next steps","title":"Find more answers","text":"","category":"section"},{"location":"10_sources/","page":"Next steps","title":"Next steps","text":"If you're looking for an answer, the community is the best place to get some help very quickly. My first choice is always the JuliaLang Forum. If that doesn't work, the Julia Language Slack is next door. But the docs are also ok, if you're either certain or desperate to find your answer there. There is also this great video tutorial that helped me get started developing packages in Julia.","category":"page"},{"location":"04_new_features/#Develop-new-features","page":"Feature Development","title":"Develop new features","text":"","category":"section"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"From now on, I suggest that you follow these steps every time you enter Julia and want to further build your package, here named \"ProjectName\":","category":"page"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"# switch to shell command line\n;\n# set project as working directory\ncd ProjectName.jl/\n[delete-key]\n# switch to package manager command line\n]\n# activate current project\nactivate .\n[delete-key]\n# load project utilities\nusing ProjectName","category":"page"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"Initially, many different errors might arise due to precompilation issues and local conflicts between different versions of the package being developed. There is no single and easy solution for this and sometimes you just have to live with it until the package gets registered, but note that those are mainly local issues and everything (the package building) should run smoothly on the GitHub Actions host machine, once you set it up.","category":"page"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"Still, you can try to start Julia with a few optargs to skip precompilation and directly activate your project:","category":"page"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"cd ProjectName.jl\njulia --startup-file=no --project=.","category":"page"},{"location":"04_new_features/","page":"Feature Development","title":"Feature Development","text":"Learn more about setting up project environments in this article.","category":"page"},{"location":"06_code_cov/#Analyse-code-coverage","page":"Code Coverage","title":"Analyse code coverage","text":"","category":"section"},{"location":"06_code_cov/","page":"Code Coverage","title":"Code Coverage","text":"It's time to automatise unit testing and code coverage analysis. There are several options out there, but personally I fancy Codecov, because it's free open source and doesn't give too many problems. Begin with adding the following workflow to your .github/workflows/ directory, maybe as CI.yml:","category":"page"},{"location":"06_code_cov/","page":"Code Coverage","title":"Code Coverage","text":"name: CI\non:\n  - push\n  - pull_request\njobs:\n  test:\n    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }} - ${{ github.event_name }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        version:\n          - '1.6'\n          - 'nightly'\n        os:\n          - ubuntu-latest\n          - macOS-latest\n        arch:\n          - x64\n    steps:\n      - name: Check out\n        uses: actions/checkout@v2\n\n      - name: Set up Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: ${{ matrix.version }}\n          arch: ${{ matrix.arch }}\n\n      - name: Load cache\n        uses: actions/cache@v1\n        env:\n          cache-name: cache-artifacts\n        with:\n          path: ~/.julia/artifacts\n          key: ${{ runner.os }}-test-${{ env.cache-name }}-${{ hashFiles('**/Project.toml') }}\n          restore-keys: |\n            ${{ runner.os }}-test-${{ env.cache-name }}-\n            ${{ runner.os }}-test-\n            ${{ runner.os }}-\n      - name: Build package\n        uses: julia-actions/julia-buildpkg@v1\n\n      - name: Run tests\n        uses: julia-actions/julia-runtest@v1\n\n      - name: Process code coverage\n        uses: julia-actions/julia-processcoverage@v1\n\n      - name: Run codecov action\n        uses: codecov/codecov-action@v1\n        with:\n          file: lcov.info\n        env:\n          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}","category":"page"},{"location":"06_code_cov/","page":"Code Coverage","title":"Code Coverage","text":"The last line up here will look for a secret token stored in your repository to connect and upload the code coverage reports to Codecov, so go to your Codecov account, enable access to your repository and store the secret token provided by Codecov in the settings of your repo. After a couple of commits, you should start to see percent coverage and other statistics on the Codecov page of your repo and can also add the Codecov badge to its README.","category":"page"},{"location":"06_code_cov/","page":"Code Coverage","title":"Code Coverage","text":"Learn more about code coverage at this tutorial and at Codecov Quick Start.","category":"page"},{"location":"02_pkg_template/#Make-a-package-template","page":"Package Template","title":"Make a package template","text":"","category":"section"},{"location":"02_pkg_template/","page":"Package Template","title":"Package Template","text":"It might be time-consuming to build your own architecture from scratch, but thanks to PkgTemplates.jl this procedure is automatic:","category":"page"},{"location":"02_pkg_template/","page":"Package Template","title":"Package Template","text":"# create a package template named \"MyPkg\"\nusing PkgTemplates\nt = Template()\nt(\"MyPkg\")","category":"page"},{"location":"02_pkg_template/","page":"Package Template","title":"Package Template","text":"There is a bunch of additional plugins and features that you can insert in your package draft, such as CI and documentation, but I suggest that you don't overdo with them, because they make it more difficult to find your way among the many generated files. More often than not I just create a basic template with the command above and then add more features manually.","category":"page"},{"location":"02_pkg_template/","page":"Package Template","title":"Package Template","text":"Also, it is good practice to generate the draft package in an empty directory and only then you import the modules and examples that you've already written. You can put the former in the src and the latter in the examples directories, respectively.","category":"page"},{"location":"02_pkg_template/","page":"Package Template","title":"Package Template","text":"Learn more about package templates at PkgTemplates.jl and JuliaLang.","category":"page"},{"location":"09_pkg_reg/#Register-the-new-package","page":"Registration","title":"Register the new package","text":"","category":"section"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"Before registering your package, consider the following checklist:","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"package successfully compiles on a local machine\nfunctions and utilities are loaded and callable\ndocs are rendered and include utility docstrings\ncode coverage lies above 70% and tests don't fail","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"If so, then the next step is to install Registrator.jl on your GitHub repository through these instructions and add a new workflow as .github/workflows/TagBot.yml:","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"name: TagBot\non:\n  issue_comment:\n    types:\n      - created\n  workflow_dispatch:\njobs:\n  TagBot:\n    if: github.event_name == 'workflow_dispatch' || github.actor == 'JuliaTagBot'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: JuliaRegistries/TagBot@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n          ssh: ${{ secrets.DOCUMENTER_KEY }}","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"The workflow above opens a pull request in the General Registry every time you write the comment @JuliaRegistrator register inside an issue of your repo. After registration is triggered, you can check if the pull request passes all the checks and can therefory be automatically merged after a stopwatch time of about 3 days. Usually, a few fixes might be necessary, such as:","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"setting compat requirements for dependencies and julia itself (I recommend \"1\" for the latter)\nchanging the package name because it's too short or too similar to other package names","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"For the first case, just update the Compat.toml, commit and retrigger the registrator with the comment; the pull request will be updated. For the second case, you'll have to change the name of your repo and triggering registration will open a new pull request. The change of name might also cause some issues for the docs deployment, so make sure that you changed all occurrences of the name in the Documenter.yml as well.","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"New versions can also be registered with this method, but the version has to be manually upgraded in the Project.toml and should follow the guidelines for semantic versioning. In addition, packages can also be submitted via the JuliaHub interface, which is more user-friendly for those who are not familiar with GitHub issues.","category":"page"},{"location":"09_pkg_reg/","page":"Registration","title":"Registration","text":"Learn more about package registration, the General Registry and semantic versioning at JuliaHub, standard and guidelines and this specification.","category":"page"},{"location":"07_write_docs/#Write-and-deploy-documentation","page":"Docs Generation","title":"Write and deploy documentation","text":"","category":"section"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"Now we'll look into the docs directory, which is responsible for the building and deployment of the documentation. This directory has its own Project.toml, therefore you can activate it and add new deps just like you did for the main project. At least, it should contain Documenter (the documentation generator for Julia) and your main project as [deps] entries.","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"The package template has already prepared the files src/index.md, which serves as the home page of the deployed docs, and make.jl, which tells Julia how to build the docs, what dependencies to load, what files to include and in which order they should appear. The latter should look something like this:","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"using ProjectName, Documenter\nENV[\"GKSwstype\"] = \"100\"\n\nbase_url = \"https://github.com/OrganisationName/ProjectName.jl/blob/main/\"\n\nmakedocs(format=Documenter.HTML(),\n         authors = \"authors\",\n         sitename = \"ProjectName.jl\",\n         modules = [ProjectName],\n         pages=[\n             \"Home\" => \"index.md\",\n             \"Examples\" => \"examples.md\"\n               ])\n\ndeploydocs(repo=\"github.com/OrganisationName/ProjectName.jl\", push_preview=true)","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"After you've added some content to the index.md and maybe also to examples.md (down below we see worthwhile material to include), try to build the docs locally with the following code:","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"# switch to the shell command line\n;\n# set \"docs\" as working directory\ncd docs\n# build docs\njulia make.jl","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"After a while, you'll see a build directory appearing in docs, click on index.html to open the local deployment of the docs.","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"The docs should primarily showcase the descriptions of the utilities defined in src just next to the main module. Those descriptions are called docstrings and you can annotate them upstream the corresponding function in the src/ files. For example:","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"\"\"\"\n    sum(a::Float64, b::Float64)\nComputes the sum of `a` and `b`.\n# Arguments\n- `a::Float64`: first arg.\n- `b::Float64`: second arg.\n\"\"\"\nsum(a::Float64, b::Float54) = a + b","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"The docstring enclosed between the triple quotes can then be rendered in the docs with the following syntax:","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"```@docs\nsum\nfunction2\nfunction3\n```","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"Code chunks with examples can also be run inside the docs and the produced images can be added in the form of md links:","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"```@repl\nusing ProjectName\nusing Plots\n\nout = sum(2, 3)\nplot(out, 2, 3)\n\nsavefig(\"plot1.png\"); nothing # hide\n```","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"And then ![plot1](plot1.png) in the next line. Note that this might take some troubleshooting before it actually works out.","category":"page"},{"location":"07_write_docs/","page":"Docs Generation","title":"Docs Generation","text":"Learn more about generating documentation in Julia and docstring syntax at Documenter.jl.","category":"page"},{"location":"03_manage_deps/#Manage-dependencies","page":"Dependency Management","title":"Manage dependencies","text":"","category":"section"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"You might wonder how your package keeps track of its credentials, such as name, uuid, authors and name, as well as more practical stuff like dependencies, campatibility requirements and similar things. All this information is stored in the Project.toml.","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"Especially when it comes to dependencies, it is not a smart idea to manually modify the keys and values within this file; it is much more efficient to leave this job to the Julia package manager, which you can access by typing the special key ]. For instance, you can activate the current project and  automatically add new deps to it as follows:","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"# switch to the package manager command line\n]\n# activate the project defined by the \"Project.toml\" in the current directory\nactivate .\n# check project status and current dependencies\nstatus\n# add new dependencies to the \"Project.toml\"\nadd FdeSolver, MicrobiomeAnalysis","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"If you then check the Project.toml, you'll see the new deps listed under [deps].","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"Another important matter is addressed by the [compat] section of this file; namely, it accounts for the compatibility requirements of your package utilities. Again, those keys don't have to be inserted manually, since Julia provides the so-called CompatHelper bot which takes care of the compat requirements for you by making pull requests in the GitHub repo. To trigger the bot, all you need to do is include the following GitHub Actions workflow as .github/workflows/CompatHelper.yml:","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"name: CompatHelper\non:\n  schedule:\n    - cron: 0 0 * * *\n  workflow_dispatch:\njobs:\n  CompatHelper:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Pkg.add(\"CompatHelper\")\n        run: julia -e 'using Pkg; Pkg.add(\"CompatHelper\")'\n      - name: CompatHelper.main()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          COMPATHELPER_PRIV: ${{ secrets.DOCUMENTER_KEY }}\n        run: julia -e 'using CompatHelper; CompatHelper.main()'","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"A word of care should be made that the CompatHelper doesn't check whether the deps you added make sense, it just finds the best compat requirement, so you are responsible to provide only those dependencies that are meaningful for your package.","category":"page"},{"location":"03_manage_deps/","page":"Dependency Management","title":"Dependency Management","text":"Learn more about package components and dependencies, the Julia REPL and the CompatHelper at Pkg.jl, Julia REPL and CompatHelper.jl.","category":"page"},{"location":"05_unit_test/#Implement-unit-testing","page":"Unit Testing","title":"Implement unit testing","text":"","category":"section"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"Tests can be found in the test directory. The package template has already prepared the draft in runtests.jl that you can fill with @test macros, which check if the conditionals in the same line are true or false. For example:","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"using Test\nusing ProjectName\n\n@testset \"ProjectName.jl\" begin\n\n    var1 = 2 + 2\n    var2 = 2 * 2\n\n    @test var1 == var2\n\nend","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"You can then run the tests locally from the package manager command line as follows:","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"]\nactivate .\n# run tests defined in \"test\" directory\ntest","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"This is quite nice. However, the amount of tests you make will increase exponentially as you add more features to your package, and you might want to split the tests into multiple files to avoid confusion and conflicts among dependencies (if some utilities depend on different externals). For this, SafeTestSets.jl comes into play:","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"using SafeTestsets\n\n@safetestset \"Run first test file\" begin include(\"test1.jl\") end\n\n@safetestset \"Run second test file\" begin include(\"test2.jl\") end\n\n@safetestset \"Run third test file\" begin include(\"test3.jl\") end","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"After which, you can write tests with the same syntax as in two chunks upstream and run them as in the second-to-last chunk, with the @safetestset being defined in runtests.jl and all other @testset in as many files as you like. Also, don't forget to add SageTestSets.jl to your extras and targets in the Project.toml.","category":"page"},{"location":"05_unit_test/","page":"Unit Testing","title":"Unit Testing","text":"Learn more about unit testing and macros at Test and JuliaLang.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This tutorial is meant to walk you through the package development workflow in Julia. I will base my explanations on my own experience building FdeSolver.jl and MicrobiomeAnalysis.jl as well as valuable resources by others that I came across online.","category":"page"}]
}
